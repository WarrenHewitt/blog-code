<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Warren&#39;s Blog</title>
    <meta name="description" content="blog &amp; note">
    <link rel="icon" href="/blog/favicon.ico">
    
    <link rel="preload" href="/blog/assets/css/0.styles.817eb272.css" as="style"><link rel="preload" href="/blog/assets/js/app.275ad5ce.js" as="script"><link rel="preload" href="/blog/assets/js/2.8b834471.js" as="script"><link rel="preload" href="/blog/assets/js/15.40cc011c.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f33aaefa.js"><link rel="prefetch" href="/blog/assets/js/11.f4740c2f.js"><link rel="prefetch" href="/blog/assets/js/12.277f66c7.js"><link rel="prefetch" href="/blog/assets/js/13.d8ed42be.js"><link rel="prefetch" href="/blog/assets/js/14.8113f790.js"><link rel="prefetch" href="/blog/assets/js/16.43f7550e.js"><link rel="prefetch" href="/blog/assets/js/17.7207b26c.js"><link rel="prefetch" href="/blog/assets/js/18.8107aa55.js"><link rel="prefetch" href="/blog/assets/js/19.022be4d3.js"><link rel="prefetch" href="/blog/assets/js/20.16e91c7c.js"><link rel="prefetch" href="/blog/assets/js/21.bab9a331.js"><link rel="prefetch" href="/blog/assets/js/22.72bc2960.js"><link rel="prefetch" href="/blog/assets/js/23.0019eeee.js"><link rel="prefetch" href="/blog/assets/js/24.22a4092f.js"><link rel="prefetch" href="/blog/assets/js/25.65f2a5c0.js"><link rel="prefetch" href="/blog/assets/js/3.9f6d9071.js"><link rel="prefetch" href="/blog/assets/js/4.3ff2fe10.js"><link rel="prefetch" href="/blog/assets/js/5.ef3583fd.js"><link rel="prefetch" href="/blog/assets/js/6.7cf359f7.js"><link rel="prefetch" href="/blog/assets/js/7.3a0f907c.js"><link rel="prefetch" href="/blog/assets/js/8.bfc32a00.js"><link rel="prefetch" href="/blog/assets/js/9.55caeb64.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.817eb272.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="Warren's Blog" class="logo"> <span class="site-name can-hide">Warren's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/fe.html" class="nav-link">前端</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">笔记</a></div><div class="nav-item"><a href="https://github.com/WarrenHewitt/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/fe.html" class="nav-link">前端</a></div><div class="nav-item"><a href="/blog/note/" class="nav-link router-link-active">笔记</a></div><div class="nav-item"><a href="https://github.com/WarrenHewitt/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/note/examination.html" class="sidebar-link">笔试</a></li><li><a href="/blog/note/D3.html" class="sidebar-link">D3</a></li><li><a href="/blog/note/css.html" class="sidebar-link">css</a></li><li><a href="/blog/note/git.html" class="sidebar-link">git</a></li><li><a href="/blog/note/html.html" class="sidebar-link">html</a></li><li><a href="/blog/note/java.html" class="active sidebar-link">java</a></li><li><a href="/blog/note/javascript.html" class="sidebar-link">javascript</a></li><li><a href="/blog/note/mini-programe.html" class="sidebar-link">mini-programe</a></li><li><a href="/blog/note/mysql-mongo.html" class="sidebar-link">mysql-mongo</a></li><li><a href="/blog/note/node.html" class="sidebar-link">node</a></li><li><a href="/blog/note/python.html" class="sidebar-link">python</a></li><li><a href="/blog/note/react.html" class="sidebar-link">react</a></li><li><a href="/blog/note/typescript.html" class="sidebar-link">typescript</a></li><li><a href="/blog/note/vue.html" class="sidebar-link">vue</a></li><li><a href="/blog/note/web-app.html" class="sidebar-link">web-app</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#java">java</a><ul><li><a href="#执行">执行</a></li><li><a href="#语法相关">语法相关</a></li></ul></li><li><a href="#类">类</a><ul><li><a href="#对象">对象</a></li><li><a href="#成员变量和局部变量">成员变量和局部变量</a></li><li><a href="#构造方法">构造方法</a></li></ul></li><li><a href="#uml-统一建模语言">UML 统一建模语言</a></li><li><a href="#异常处理">异常处理</a></li><li><a href="#时间处理">时间处理</a></li><li><a href="#集合">集合</a><ul><li><a href="#list">List</a></li><li><a href="#set：">Set：</a></li><li><a href="#map">Map:</a></li></ul></li><li><a href="#泛型">泛型</a></li><li><a href="#javadoc">javadoc</a><ul><li><a href="#hashmap">HashMap</a></li></ul></li><li><a href="#学习笔记">学习笔记</a><ul><li><a href="#相关名词">相关名词</a></li><li><a href="#安装jdk">安装JDK</a></li><li><a href="#jdk与jvm">JDK与JVM</a></li></ul></li><li><a href="#教程笔记：">教程笔记：</a><ul><li><a href="#环境变量">环境变量</a></li><li><a href="#用记事本编写程序">用记事本编写程序</a></li><li><a href="#使用ide">使用IDE</a></li></ul></li><li><a href="#spring">spring</a><ul><li><a href="#spring-mvc">spring mvc</a></li><li><a href="#spring-boot">spring boot</a></li></ul></li><li><a href="#第三方包">第三方包</a></li></ul></div> <div class="table-of-contents"><ul><li><a href="#java">java</a><ul><li><a href="#执行">执行</a></li><li><a href="#语法相关">语法相关</a></li></ul></li><li><a href="#类">类</a><ul><li><a href="#对象">对象</a></li><li><a href="#成员变量和局部变量">成员变量和局部变量</a></li><li><a href="#构造方法">构造方法</a></li></ul></li><li><a href="#uml-统一建模语言">UML 统一建模语言</a></li><li><a href="#异常处理">异常处理</a></li><li><a href="#时间处理">时间处理</a></li><li><a href="#集合">集合</a><ul><li><a href="#list">List</a></li><li><a href="#set：">Set：</a></li><li><a href="#map">Map:</a></li></ul></li><li><a href="#泛型">泛型</a></li><li><a href="#javadoc">javadoc</a><ul><li><a href="#hashmap">HashMap</a></li></ul></li><li><a href="#学习笔记">学习笔记</a><ul><li><a href="#相关名词">相关名词</a></li><li><a href="#安装jdk">安装JDK</a></li><li><a href="#jdk与jvm">JDK与JVM</a></li></ul></li><li><a href="#教程笔记：">教程笔记：</a><ul><li><a href="#环境变量">环境变量</a></li><li><a href="#用记事本编写程序">用记事本编写程序</a></li><li><a href="#使用ide">使用IDE</a></li></ul></li><li><a href="#spring">spring</a><ul><li><a href="#spring-mvc">spring mvc</a></li><li><a href="#spring-boot">spring boot</a></li></ul></li><li><a href="#第三方包">第三方包</a></li></ul></div><p></p> <hr> <h2 id="java"><a href="#java" class="header-anchor">#</a> java</h2> <ul><li><p>双引号表示字符串；单引号表示字符，返回ascii码，可与数字进行运算</p></li> <li><p>包声明；在包文件头部 <code>package xxx</code></p></li></ul> <h3 id="执行"><a href="#执行" class="header-anchor">#</a> 执行</h3> <ol><li>编译 <code>javac Hello.java</code></li> <li>执行 Hello.class 使用 <code>java Hello</code></li></ol> <h3 id="语法相关"><a href="#语法相关" class="header-anchor">#</a> 语法相关</h3> <ul><li>语句后面注意加分号</li></ul> <h4 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h4> <ul><li>java 关键字区分大小写</li></ul> <h4 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h4> <ul><li>给变量， 类，方法等命名的符号</li> <li>数字，字母，下划线，$，组成，不能以数字开头</li> <li>严格区分大小写</li></ul> <h4 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h4> <ul><li>区分大小写</li> <li>变量类型 变量名 = 变量值</li> <li>先申明，后使用</li></ul> <h4 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h4> <ul><li>java是强类型</li></ul> <ol><li>基本数据类型(括号中的值为字节)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>|-- 数值型  
    |-- 整数：byte，short，long，int(4)
    |-- 浮点：float(4)数字后添加字母f， double(8)
|-- 字符型 char(2) 用单引号 只能是一个字符
|-- 布尔型 boolean(1)  
</code></pre></div><ul><li><p>int 默认初始值：0</p></li> <li><p>基本类型包装类(与基本类型之间可以自动转换)：</p></li></ul> <p>Byte Short Integer Long Float Double Character Boolean</p> <div class="language- extra-class"><pre class="language-text"><code>int num = 123;
Integer n1 = new Integer(num)
float n2 = n1.floatValue()
</code></pre></div><ul><li>基本类型转换为字符串
<ul><li>使用 基本类型的封装类的 toString() 方法</li> <li>使用 String 类的 valueOf() 方法</li> <li>利用与 空字符串相加</li></ul></li> <li>字符串转基本类型
<ul><li>包装类.parseXxx(xx)</li> <li>包装类.valueOf(xx)</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>int num = 12;
System.out.println(Integer.toString(num));
System.out.println(String.valueOf(num));
System.out.println(num + &quot;&quot;);

String s = &quot;12.36&quot;;
Double db = Double.parseDouble(s);
Double dd = Double.valueOf(s);
</code></pre></div><ol start="2"><li>引用类型</li></ol> <div class="language- extra-class"><pre class="language-text"><code>|-- 类
|-- 接口
|-- 数组
</code></pre></div><p>float与double的区别：</p> <ul><li>float占4字节，32位(但有9位要拿来放符号位和指数位)，最大数 8388608 最多7位，但只能保证6位精准</li> <li>double 位数部分52位 最大数2^52 4503599627370496 精度15-16位</li> <li>double消耗内存是float的两倍，double的运算速度比float慢</li></ul> <h5 id="string"><a href="#string" class="header-anchor">#</a> String</h5> <ul><li>两种方式： <code>String str = &quot;&quot;</code> 或 <code>String str = new String(&quot;&quot;)</code></li> <li>引用数据类型 ；是字符串，用双引号</li> <li>位于java.lang包中，默认自动引入所有的程序</li> <li>每次创建一个字符串都是新对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>String s1 = &quot;字符串&quot;;
String s2 = &quot;字符串&quot;;
String s3 =  new String(&quot;字符串&quot;);
s1 和 s2 相等 因为多次出现的字符常量，java编译时只创建一个
s1，s2 和 s3 是不同的对象
s1 存放的是指向 &quot;字符串&quot;对象存在于堆内存中的地址
s1.equals(s3)  返回true；equals只比较内容
== 比较的是内存地址
</code></pre></div><p>程序中频繁操作字符串，就会产生很多的临时变量，使用<code>StringBuilder</code> 和 <code>StringBuffer</code> 就不会出现该问题；二者基本相似，不同在于 <code>StringBuilder</code>是线程安全的， <code>StringBuilder</code>没有实现但性能更高；所以一般情况下创建内容可变字符串，优先考虑 <code>StringBuilder</code></p> <h5 id="自动类型转换"><a href="#自动类型转换" class="header-anchor">#</a> 自动类型转换</h5> <ol><li>两种类型要相互兼容</li> <li>目标类型要大于源类型</li></ol> <h5 id="强制类型转换"><a href="#强制类型转换" class="header-anchor">#</a> 强制类型转换</h5> <p>语法：(要转化为的数据类型)值</p> <h4 id="运算符"><a href="#运算符" class="header-anchor">#</a> 运算符</h4> <ul><li>算术运算符</li></ul> <p><code>+ - * / % ++ --</code></p> <ul><li>% 用来求余数，也称为”取模运算符</li></ul> <hr> <ul><li>赋值运算符
<code>= += -= += /= %=</code></li></ul> <hr> <ul><li>比较运算符
<code>&gt; &lt; &gt;= &lt;=</code> 两边的操作数是数值类型</li></ul> <p><code>== !=</code> 两边既可以是数值类型也可以是引用类型</p> <hr> <ul><li>逻辑运算符
<code>&amp;&amp; || !</code></li></ul> <p><code>^</code> 有且必须一个为true一个为false</p> <ul><li>条件运算符</li></ul> <p><code>? :</code> 三元运算符</p> <h4 id="条件语句"><a href="#条件语句" class="header-anchor">#</a> 条件语句</h4> <h5 id="swith"><a href="#swith" class="header-anchor">#</a> swith</h5> <ul><li><p>switch后的值必须是整形或字符型</p></li> <li><p>case后面的可以使常量也可以是常量表达式</p></li> <li><p>匹配后，只有遇到break或语句结束，才会停止执行，否则会执行下一个case中的值</p></li></ul> <h5 id="for-循环变量初始化-循环条件-循环变量变化"><a href="#for-循环变量初始化-循环条件-循环变量变化" class="header-anchor">#</a> for(循环变量初始化;循环条件;循环变量变化) {}}</h5> <ol><li>循环变量初始化在循环中只执行一次</li> <li>进行循环条件的判断，为真执行循环体</li> <li>改变循环变量的值</li> <li><code>2 -&gt; 3 -&gt;4</code></li></ol> <ul><li>括号中的三个表达式可以省略但是分号不能省略</li> <li>循环变量初始化和循环变量变化，可以用逗号隔开</li> <li>break continue</li></ul> <h5 id="foreach"><a href="#foreach" class="header-anchor">#</a> foreach</h5> <p>遍历数组，集合
语法：</p> <div class="language- extra-class"><pre class="language-text"><code>for(类型 xxx: 遍历对象) {
  print(xxx)
}
</code></pre></div><h4 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h4> <ul><li><p>声明：</p> <ol><li>类型[] xxx;</li> <li>类型 xxx[];</li></ol></li> <li><p>分配空间
xxx = new 类型[ 长度]</p></li></ul> <p>合并以上： <code>int[] xxx = new int[ 3]</code></p> <ul><li>赋值</li></ul> <p><code>xxx[ 1] = xx</code></p> <p><code>int[] xxx = { 11, 12, 13 }</code> 等同于 <code>int[] xxx = new int[ 不能有长度]{ 11, 12, 13 }</code></p> <ul><li>工具方法Arrays的使用</li></ul> <div class="language- extra-class"><pre class="language-text"><code>import java.util.Arrays;
String[] names = {&quot;sports&quot;, &quot;game&quot;, &quot;movie&quot; };
Arrays.sort(names);
System.out.println(&quot;all name:&quot; + Arrays.toString(names));
</code></pre></div><h5 id="二维数组"><a href="#二维数组" class="header-anchor">#</a> 二维数组</h5> <div class="language- extra-class"><pre class="language-text"><code>- 声明：int[][] arr = new int[2][3] 或者  int[][] arr ={{1,2,3},{4,5,6}}

- 赋值只能具体到某个值进行操作： arr[1] = {1,3,3}; arr = {{1,3,3}, {1,4,3}} 报错
</code></pre></div><h4 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h4> <p>语法：</p> <div class="language- extra-class"><pre class="language-text"><code>访问修饰符 返回值类型 方法名(类型) {
  方法体
}
</code></pre></div><ul><li>访问修饰符：public, protected, private,或省略</li> <li>返回值类型：没有返回值用void</li></ul> <h5 id="方法重载"><a href="#方法重载" class="header-anchor">#</a> 方法重载</h5> <ul><li>同一个类中</li> <li>相同的方法名</li> <li>方法的参数个数，顺序，类型不同</li> <li>与方法的修饰符，返回值没有关系</li></ul> <h2 id="类"><a href="#类" class="header-anchor">#</a> 类</h2> <ol><li>所有java程序都是以类为组织单元</li> <li>定义类（定义类名，定义属性，定义方法）</li></ol> <h3 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h3> <ul><li>类是对象的类型</li> <li>创建对象 <code>类名 对象名 = new 构造方法()</code></li> <li>使用对象 对象名加调用</li></ul> <h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="header-anchor">#</a> 成员变量和局部变量</h3> <p>成员变量：在类中定义，描述对象将要有什么
局部变量：类的方法中定义，方法中保存临时数据</p> <ul><li>只会给成员变量初始值</li> <li>成员变量和局部变量同名，遵循就近原则</li></ul> <h3 id="构造方法"><a href="#构造方法" class="header-anchor">#</a> 构造方法</h3> <ul><li>new 构造方法 创建新对象</li> <li>定义用来初始化对象的方法，构造方法与类同名且没有返回值</li></ul> <div class="language- extra-class"><pre class="language-text"><code>public 构造方法名(参数) {
  
}
</code></pre></div><ul><li>没有指定无参的构造方法，系统会自动生成一个，也可以自己写无参构造方法</li> <li>有参数构造方法</li></ul> <h4 id="静态变量"><a href="#静态变量" class="header-anchor">#</a> 静态变量</h4> <ul><li><p>在类中定义</p></li> <li><p>用static修饰，它属于整个类所有，而不是某个对象所有；可以直接用类名进行访问</p></li> <li><p>static可修饰变量、方法、代码块</p></li></ul> <h4 id="final-关键字"><a href="#final-关键字" class="header-anchor">#</a> final 关键字</h4> <p>语法 ： final xxx</p> <ol><li>修饰类   类不可继承</li> <li>修饰方法  方法不可覆盖</li> <li>修饰属性  只可以在初始化时赋值一次</li></ol> <p>子类构造方法中，没有显示调用父类的构造方法。则系统默认调用父类午餐的构造方法</p> <p>Object类是所有类的父类</p> <ul><li>toString() 方法重写</li> <li>equals  比较对象的引用地址是否相同</li></ul> <h4 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h4> <p>同一个接口，使用不同的实例，执行不同的操作</p> <ol><li><p>引用的多态  父类的引用指向子类的对象  父类的引用指向本类的对象 <code>Parent p = new Child();</code></p></li> <li><p>继承</p></li> <li><p>重写,子类重写父类方法</p></li></ol> <p>不能使用子类的特有的属性和方法，强制转换：<code>Tiger tg = (Tiger) am;</code> 后即可访问</p> <p>tg 指向最开始在堆内存中创建的那个 Tiger类型的对象</p> <p>减少了多余对象的创建</p> <h2 id="uml-统一建模语言"><a href="#uml-统一建模语言" class="header-anchor">#</a> UML 统一建模语言</h2> <p>图形话语言</p> <ol><li>用例图</li> <li>序列图： 按照交互，发生的一系列顺序</li> <li>类图</li></ol> <h2 id="异常处理"><a href="#异常处理" class="header-anchor">#</a> 异常处理</h2> <div class="language- extra-class"><pre class="language-text"><code>Throwable 类 java中所有不正常类都继承于它
  -- Error: 虚拟机错误，线程死锁，一般出现 程序就挂了
  -- Exception：编码、环境、用户操作输入出现问题
     -- RuntimeException：非检查异常，数组越界，引用空对象的属性或方法，等等；由虚拟机自动抛出并捕获。
         -- NullPointerException(空指针异常) `String a = null;print(a.length())`
         -- ArrayIndexOutOfBoundsException(数组下标越界)
         -- ClassCastException(类型转换异常)
         -- ArithmeticExceptior(算术异常) `1/0`
     -- 其它：检查异常；手动添加捕获，以及处理语句
         -- IOException(文件异常)
         -- SQLException(SQL异常)
</code></pre></div><ul><li><p>catch 多异常捕获，从子类到父类捕获</p></li> <li><p>finally语句中去释放占用的资源</p></li> <li><p>抛出异常：throw</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>throws 声明将要抛出何种类型的异常
如下是将错误抛出给更上一层的tryCatch，否则就直接在内部写tryCatch
public void 方法名(参数列表) throws Exception {
  // 调用会抛出异常的方法或
  throw new Exception(&quot;异常说明&quot;);
} 
</code></pre></div><ul><li>自定义异常 继承Exception</li></ul> <h2 id="时间处理"><a href="#时间处理" class="header-anchor">#</a> 时间处理</h2> <ul><li>将 Calendar 转换为 Date  使用 getTime()</li> <li>getTimeInMillis() 获取 Calendar 的时间值，以毫秒为单位</li></ul> <h2 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h2> <ul><li>集合中元素可以是任意类型的对象的引用</li> <li>在类的内部对数据进行组织</li> <li>简单快捷的搜索大数量的条目</li> <li>有些集合提供了一系列有序的元素，可以在序列中快速的插入或删除有关元素</li> <li>有些集合，提供了映射关系，可以通过关键字去快速查找唯一对象，这个关键字可以是任意类型</li> <li>集合长度可变</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Collection-- List  排列有序，可重复
             -- ArrayList(数组序列) 
          -- Queue 排列有序，可重复
             -- LinkedList(链表)
          -- Set 无序，不可重复
             == HashSet(哈希集)
存储的是一个一个的对象

Map -- HashMap(哈希表)
映射关系，键值对
</code></pre></div><ul><li>hashMap.values() 返回集合包含的值</li></ul> <h3 id="list"><a href="#list" class="header-anchor">#</a> List</h3> <ul><li>调用contains方法，遍历list中的每一个元素，再调用每一个元素的equals方法，与传入的参数比较</li></ul> <h3 id="set："><a href="#set：" class="header-anchor">#</a> Set：</h3> <ul><li>Set 中没有 get 方法</li> <li>循环Set 每次的结果循序不一致</li> <li>调用 contains 时，先调用每一个元素的 hashCode 方法返回hash码，如果hash码相同，再调用equals判断是否相等。都相等才相等</li></ul> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map:</h3> <ul><li>元素为键值对 key-value</li> <li>键值对以Entry类型的对象形式存在</li> <li>key不可重复 value可以</li> <li>Map接口提供了返回key值集合，value值集合以及Entry集合的方法</li> <li>支持泛型，<code>Map&lt; key类型, value类型&gt;</code></li></ul> <h4 id="hashmap"><a href="#hashmap" class="header-anchor">#</a> HashMap</h4> <ul><li>是Map的一个重要实现类，</li> <li>其中的Entry对象是无序列的</li> <li>key和value都可以为null</li></ul> <h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <ul><li>规定了某个集合只可以存放特定类型的对象，会在编译期间进行类型检测</li> <li>泛型集合不能添加除泛型及其子类型以外的对象，否则会报错</li> <li>不能是基本类型，要用基本类型，要使用包装类</li></ul> <h2 id="javadoc"><a href="#javadoc" class="header-anchor">#</a> javadoc</h2> <ul><li><p>intelliJ 打开 Tools -&gt; generate JavaDoc</p></li> <li><p>如果报编码错误，在 other command 中添加 -encoding utf-8 -charset utf-8</p></li></ul> <h3 id="hashmap-2"><a href="#hashmap-2" class="header-anchor">#</a> HashMap</h3> <ul><li>ConcurrentHashMap 解决其在多线程编程中是线程不安全的，而Hashtable由于使用了synchronized修饰方法而导致执行效率不高</li></ul> <h2 id="学习笔记"><a href="#学习笔记" class="header-anchor">#</a> 学习笔记</h2> <ul><li><p>Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果;SUN公司制定了一系列的Java虚拟机规范;</p></li> <li><p>java se 是标准版，包含标准JVM和标准库； java ee 是企业版，加了大量的api和库，两者虚拟机一致；java me 针对嵌入式设备的“瘦身版”,几乎没有使用；</p></li></ul> <h3 id="相关名词"><a href="#相关名词" class="header-anchor">#</a> 相关名词</h3> <ul><li>JVM: java virtual machine</li> <li>JDK：java development kit（套件）</li> <li>JRE：java runtime environment</li> <li>JSR规范：Java Specification Request</li> <li>JCP组织：Java Community Process</li></ul> <p>关系</p> <div class="language- extra-class"><pre class="language-text"><code>  —— —— —— —— compiler，debugger， etc
 |
JDK —— 
 |    |
 |   JRE —— JVM + runtime library
 |    |
 |  ——

Windows | Linux │ macOS │ others 
</code></pre></div><h3 id="安装jdk"><a href="#安装jdk" class="header-anchor">#</a> 安装JDK</h3> <ul><li><p>oracle官网 -&gt; product -&gt; developer tools -&gt; java se jdk -&gt; Downloads -&gt; 选择最下方对应的版本下载</p></li> <li><p>安装完后，在安装路径(默认<code>C:\Program Files\Java\jdk-12.0.2</code>) 中查看</p></li> <li><p>将bin添加到环境变量</p></li></ul> <h3 id="jdk与jvm"><a href="#jdk与jvm" class="header-anchor">#</a> JDK与JVM</h3> <ul><li><p>OpenJ9：高性能可伸缩的 Java 虚拟机，可作为 Hotspot 的替代者用于 OpenJDK</p></li> <li><p>HotSpot：是JVM（Java Virtual Machine），openJDK所包含</p></li> <li><p>OpenJDK：是一个完整的开发工具包，包含其他组件，如Java 类库以及 JVM</p></li></ul> <hr> <h2 id="教程笔记："><a href="#教程笔记：" class="header-anchor">#</a> 教程笔记：</h2> <p>源文件 -&gt; 编译器 -&gt; 字节码文件 -&gt; 解释器</p> <h3 id="环境变量"><a href="#环境变量" class="header-anchor">#</a> 环境变量</h3> <p>JAVA_HOME 配置JDK安装路径 系统变量里新建(地址为jdk安装的根目录，如：D:\java)</p> <hr> <p>PATH   配置JDK命令文件的位置  在path变量中编辑即可，D:\java\bin</p> <hr> <p><strong>从java9开始可以不用配置</strong></p> <p>CLASSPATH  配置库类文件的位置 系统变量里新建(地址为jdk安装的根目录，如：D:\java\lib)</p> <hr> <p>验证环境变量配置是否正确  在命令行输入java 和javac 显示正确提示即配置正确</p> <h3 id="用记事本编写程序"><a href="#用记事本编写程序" class="header-anchor">#</a> 用记事本编写程序</h3> <ol><li>源代码文件 .java 文件</li></ol> <ul><li>可以直接运行 <code>java FirstStep.java</code></li></ul> <ol start="2"><li>使用javac命令编译 源代码文件，得到.class的字节码文件</li></ol> <ul><li>编写java文件</li> <li>用javac编译: <code>javac FirstStep.java</code> ,生成同名.class文件</li> <li>javac -encoding UTF-8 xxx.java 处理有中文</li></ul> <ol start="3"><li>解释器（不同的平台去解释字节码文件），使用java命令</li></ol> <ul><li>java是解释class文件的解释器，是class的执行引擎</li> <li>执行字节码文件不需要加后缀名</li> <li><code>java FirstStep</code>(在cmd上执行报找不到类，在bash上正常)</li></ul> <h3 id="使用ide"><a href="#使用ide" class="header-anchor">#</a> 使用IDE</h3> <ol><li>创建java项目</li> <li>创建程序包</li> <li>编写java源程序</li> <li>运行java程序(点击运行后编译器自动编译了)</li></ol> <h2 id="spring"><a href="#spring" class="header-anchor">#</a> spring</h2> <ul><li><p>一个开源框架(Spring Framework)</p></li> <li><p>轻量的控制反转IoC</p></li> <li><p>面向切面AOP的容器框架</p></li> <li><p>大小与开销两方面都是轻量的</p></li> <li><p>Bean，它代表的就是由Spring管辖的对象</p></li> <li><p>Spring MVC和Spring Boot都属于Spring，Spring MVC 是基于Spring的一个 MVC 框架，而Spring Boot 是基于Spring的一套快速开发整合包</p></li> <li><p>dependengcy: 用 mvc 选 spring web ，用 webFlux 选spring reactive web</p></li></ul> <h3 id="spring-mvc"><a href="#spring-mvc" class="header-anchor">#</a> spring mvc</h3> <ul><li><p>是spring的一部分</p></li> <li><p>主要用于开发WEB应用和网络接口，它是Spring的一个模块</p></li></ul> <h3 id="spring-boot"><a href="#spring-boot" class="header-anchor">#</a> spring boot</h3> <p>创建独立的Spring应用程序，用于创建微服务；用于简化 Spring 应用从搭建到开发的过程；</p> <h4 id="使用-spring-initializr-页面输出项目"><a href="#使用-spring-initializr-页面输出项目" class="header-anchor">#</a> 使用 Spring Initializr 页面输出项目</h4> <ol><li>勾选配置,设置好 Group ，Artifact</li> <li>下载，将其移入放置项目的文件夹</li> <li>在开发工具中选择从已有项目资源(上一步下载的压缩包加压后的文件)新建；或是选择导入项目；</li> <li>勾选相关设置</li> <li>等待安装依赖包</li> <li>完成</li></ol> <p>Artifact：可以当它为一个web项目</p> <hr> <ul><li><p>构建工具 Maven，Gradle</p></li> <li><p>spring framework  -&gt; spring boot  -&gt; spring cloud</p></li> <li><p>Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，实质是一个基于http协议的web容器; Netty能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是最大的不同</p></li> <li><p>pom.xml 文件用于 maven 构建，指定了如何编译和打包项目</p></li> <li><p>Servlet 是运行在Web服务器上的小程序，通过http协议和客户端进行交互</p></li> <li><p>@Configuration  理解为替换XML配置文件 作用于类上，相当于一个xml配置文件</p></li> <li><p>@Bean 作用于方法上，相当于xml配置中的<code>&lt; bean&gt;</code></p></li> <li><p>Optional 防止空指针提出的接口</p></li> <li><p>spring注解 @Autowired ：表示被修饰的类需要注入对象,spring会扫描所有被@Autowired标注的类,然后根据 类型 在ioc容器中找到匹配的类注入</p></li> <li><p>修改端口：<code>application.properties</code> 文件中添加 <code>server.port = 8880</code></p></li> <li><p>【spring-boot-starter-web】 在当下项目运行mvn spring-boot:run就可以直接启用一个嵌套了tomcat的web应用。如果没有提供任何服务的Cotroller,访问任何路径都会返回一个springBoot默认的错误页面 Whitelabel Error Page</p></li></ul> <h2 id="第三方包"><a href="#第三方包" class="header-anchor">#</a> 第三方包</h2> <ul><li>fastJson： 传入的对象要有 getter 方法</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/note/html.html" class="prev">html</a></span> <span class="next"><a href="/blog/note/javascript.html">javascript</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.275ad5ce.js" defer></script><script src="/blog/assets/js/2.8b834471.js" defer></script><script src="/blog/assets/js/15.40cc011c.js" defer></script>
  </body>
</html>

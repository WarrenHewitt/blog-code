<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>blog-code-test</title>
    <!-- <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script> -->
    <style>
        
       
    </style>
</head>

<body>
    <script>


        function heapSort(array) {
            let length = array.length
            /* 第一个非叶子节点（叶子节点：没有子节点的节点）： n/2 -1 */
            const node =  Math.floor(length/2) - 1

            /* 第一步先将数组构建为堆 这里是大顶堆 */
            for (let i = node; i >= 0 ; i--) {
                maxHeap(array, i, length)
            }

            /* 第二步 将堆顶元素与堆尾元素交换 再将前 (n-1) 个数重复构建堆 */
            for (let j = length - 1; j > 0; j--) {
                swap(array, 0, j)
                const _node = Math.floor((j-1)/2) - 1
                maxHeap(array, _node, j-1)
            }

            return array
        }

        function maxHeap(array, i, length) {
            let left = i*2 + 1
            let right = i*2 + 2
            let parent = i

            /* 找出子节点中比父节点大的数进行交换 */
            if(left < length && array[left] > array[parent]) {
                parent = left
            }

            if(right < length && array[right] > array[parent]) {
                parent = right
            }

            if(parent !== i) {
                swap(array,i, parent)
                /* 表示有数据移动，所以要重排一下数据移动后所影响到的父子节点 */
                maxHeap(array, parent, length)
            } 
        }

        function swap(arr, i, j) {
            var temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

        // var arr = []
        // for (let i = 0; i < 100000; i++) {
        //     arr.push(Math.random())
        // }

            console.log(heapSort([0,1,2,3,4,5]));

    </script>
</body>

</html>